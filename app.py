from flask import Flask, render_template, request, session, redirect, jsonify, make_response
from flask_jwt_extended import JWTManager, create_access_token, jwt_required
import bcrypt
from PIL import Image
import base64
import cv2
import numpy as np
import moviepy.editor as mp
from moviepy.editor import concatenate_audioclips, AudioFileClip
from moviepy.video.fx.fadeout import fadeout
from moviepy.video.fx.fadein import fadein
from moviepy.editor import ImageSequenceClip
import io
import os
import psycopg2

connection = psycopg2.connect("postgresql://divijh:sYqEBwmgRbCKkA12JYx5pA@fuckit-4297.7s5.aws-ap-south-1.cockroachlabs.cloud:26257/Project?sslmode=require")
print("Connection established to Database...")

app = Flask(__name__)

cursor = connection.cursor()

app.config['JWT_SECRET_KEY'] = 'super-secret' 
jwt = JWTManager(app)

def check_user_details_table():
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS User_Details (
        User_Id SERIAL PRIMARY KEY,
        User_Name VARCHAR(255),
        User_Email VARCHAR(255),
        User_Password VARCHAR(255),
        DOB VARCHAR(255)
        )
    """)
    connection.commit()
check_user_details_table()

def create_table():
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS Images (
            image_id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            user_id INT,
            image_name VARCHAR(255),
            image_dimensions VARCHAR(20),
            image_extension VARCHAR(10),
            image_size INT,
            image_blob BYTEA,
            image_duration INT,
            image_transition INT,
            image_selected INT,
            audio_id INT             
        )
    """)
    connection.commit()

create_table()

def create_audio_table():
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS Audio (
            audio_id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            user_id INT,
            audio_name VARCHAR(50),
            audio_data BYTEA
        )
    """)
    connection.commit()
        
create_audio_table()

app.secret_key = 'vvkimkc'

@app.route('/')
def index():
    return render_template('landing.html')

@app.route('/login', methods=['POST','GET'])
def login():
    if request.method =='POST':
        email = request.form['email']
        password = request.form['password']
        if email == 'admin@go' and password == 'admin':
            session['logged_in'] = True
            session.permanent = True  
            return redirect('/admin')
        cursor.execute('SELECT * FROM User_Details WHERE User_Email = %s', (email,))
        user = cursor.fetchone()
        if user:
            hashed_password = user[3]
            if bcrypt.checkpw(password.encode('utf-8'), hashed_password.encode('utf-8')):
                session['logged_in'] = True
                session['user_id'] = user[0]
                access_token = create_access_token(identity=email)
                session['access_token'] = access_token
                session.permanent = True 
                return redirect('/page')  
            else:
                return render_template('login_error1.html', message='Incorrect password')
        else:
            return render_template('login_error2.html', message='Email not found')
    elif 'logged_in' in session:  
        if session['logged_in']:
            return redirect('/page')
    return render_template('log.html')

@app.route('/register', methods=['GET', 'POST'])
def register():
    if request.method == 'POST':
        username = request.form['username']
        email = request.form['email']
        password = request.form['password']
        dob=request.form['dob']
        hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt())
    
        cursor.execute('SELECT * FROM User_Details WHERE User_Email = %s', (email,))
        existing_user = cursor.fetchone()
        if existing_user:
            return render_template('register_error.html', message='Email already registered')

        cursor.execute('SELECT MAX(User_Id) FROM User_Details')
        latest_user_id_row = cursor.fetchone()
        latest_user_id = latest_user_id_row[0] if latest_user_id_row and latest_user_id_row[0] else 0
        new_user_id = latest_user_id + 1

        cursor.execute('INSERT INTO User_Details (User_Id, User_Name, User_Email, User_Password,DOB) VALUES (%s, %s, %s, %s,%s)',
                    (new_user_id, username, email, hashed_password.decode('utf-8'),dob))
        connection.commit()
    
        access_token = create_access_token(identity=new_user_id)
        session['access_token'] = access_token
        session['user_id'] = new_user_id
        session.permanent = True 
        
        return redirect('/success') 

    return render_template('reg.html')

@app.route('/success')
def success():
    return render_template('success.html')

@app.route('/admin')
def admin():
    user_details=fetch_user_details()
    return render_template('adminpage.html',user_details=user_details)

def fetch_user_details():
    cursor.execute('SELECT * FROM User_Details')
    user_details = cursor.fetchall()
    return user_details

@app.route('/page')
def go():
    user_id = session.get('user_id')
    if user_id is None:
        return 'Unauthorized', 401
    images = []
    cursor.execute("SELECT image_blob, image_name, image_extension FROM Images WHERE user_id = %s", (user_id,))
    results = cursor.fetchall()
    for result in results:
        image_data = result[0]
        image_extension = result[2]
        image_name = result[1]
        
        images.append({
            'src': f"data:image/{image_extension};base64,{base64.b64encode(image_data).decode()}",
            'alt': image_name
        })
    return render_template('index.html', images=images)

@jwt_required()
@app.route('/upload', methods=['POST'])
def upload_file():
    user_id = session.get('user_id')
    if user_id is None:
        return 'Unauthorized', 401

    if 'file' not in request.files:
        return 'No file part'
    files = request.files.getlist('file')
    for file in files:
        image_data = file.read()
        image_name = file.filename
        image_size = len(image_data) 
        image_extension = file.filename.split('.')[-1]
        try:
            with Image.open(file) as img:
                image_dimensions = f"{img.width}x{img.height}"
        except Exception as e:
            image_dimensions = "Unknown"
            print(f"Error while obtaining image dimensions: {e}")
        # image_base64 = base64.b64encode(image_data).decode('utf-8')
        image_base64 = image_data
        sql = """INSERT INTO Images (user_id, image_name, image_dimensions, image_extension, image_size, image_blob, image_duration, image_transition, audio_id,image_selected) 
                VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s,%s)"""
        cursor.execute(sql, (user_id, image_name, image_dimensions, image_extension, image_size, image_base64, 1, 0, 0,0))
        connection.commit()
    return 'Files uploaded successfully'

@app.route('/images')
def display_images2():
    user_id = session.get('user_id')
    if user_id is None:
        return 'Unauthorized', 401
    images = []

    cursor.execute("SELECT image_blob, image_name, image_extension FROM Images WHERE user_id = %s", (user_id, ))
    results = cursor.fetchall()
    for result in results:
        image_data = result[0]
        image_extension = result[2]
        image_name = result[1]
        image_base64 = base64.b64encode(image_data).decode('utf-8')
        images.append({
            'src': f"data:image/{image_extension};base64,{image_base64}",
            'alt': image_name
        })

    return render_template('images.html', images=images)


@app.route('/search', methods=['GET', 'POST'])
def search_images():
    if request.method == 'GET':
        return render_template('search.html')
    elif request.method == 'POST':
        search_query = request.form.get('search_query')
    user_id = session.get('user_id')
    if user_id is None:
        return 'Unauthorized', 401  
    images = []
    cursor.execute("SELECT image_blob, image_name, image_extension FROM Images WHERE user_id = %s AND image_name LIKE %s ", (user_id, f'{search_query}%'))
    results = cursor.fetchall()
    for result in results:
        image_data = result[0]
        image_extension = result[2]
        image_name = result[1]
        image_base64 = base64.b64encode(image_data).decode('utf-8')
        images.append({
            'src': f"data:image/{image_extension};base64,{image_base64}",
            'alt': image_name,
        })
    return jsonify(images)

@app.route('/audio')
def audio_index():
        user_id = session.get('user_id')
        if user_id is None:
            return 'Unauthorized', 401
        audios = []

        cursor.execute("SELECT audio_data, audio_name FROM Audio WHERE user_id = %s", (user_id,))
        results = cursor.fetchall()
        for result in results:
            audio_data = result['audio_data']
            audio_name = result['audio_name']
            audios.append({
            'audio_data': audio_data,
            'audio_name': audio_name
        })  
        return render_template('index2.html', audios=audios)

@app.route('/upload_audio', methods=['POST'])
def upload_file_audio():
    if 'file' not in request.files:
        return 'No file part'
    files = request.files.getlist('file')
    for file in files:
        audio_data = file.read()
        audio_name = file.filename
        audio_blob = base64.b64encode(audio_data).decode('utf-8')
        sql = """INSERT INTO Audio (user_id, audio_data, audio_name) VALUES (%s, %s, %s)"""
        cursor.execute(sql, (1, audio_blob, audio_name))
        connection.commit()
    return 'Files uploaded successfully'

@app.route('/edit')
def display_images():
    user_id = session.get('user_id')
    if user_id is None:
        return 'Unauthorized', 401 
    images = []
    cursor.execute("SELECT image_id,image_blob, image_name, image_extension,image_selected,image_duration,image_transition FROM Images WHERE user_id = %s", (user_id,))
    results = cursor.fetchall()
    for result in results:
        image_id=result[0]
        image_data = result[1]
        image_extension = result[3]
        image_name = result[2]
        image_selected=result[4]
        image_duration=result[5]
        image_transition=result[6]
        images.append({
            'id': image_id,
            'src': f"data:image/{image_extension};base64,{base64.b64encode(image_data).decode('utf-8')}",
            'alt': image_name,
            'image_selected': image_selected,
            'image_duration':image_duration,
            'image_transition':image_transition
        })
        
    cursor.execute("SELECT audio_id, audio_data, audio_name FROM Audio WHERE user_id = %s", (user_id,))
    audio_results = cursor.fetchall()
    user_audios = [{
        'audio_id': audio[0],
        'audio_data': audio[1],
        'audio_name': audio[2]
    } for audio in audio_results]
    return render_template('dummy.html', images=images, user_audios=user_audios)


def fetch_image_details():
    cursor.execute('SELECT * FROM Images')
    image_details = cursor.fetchall()
    return image_details
    
def fetch_audio_from_database(audio_id):
    cursor.execute("SELECT audio_data FROM Audio WHERE audio_id = %s", (audio_id,))
    audio_data = cursor.fetchone()[0]
    audio_bytes = base64.b64decode(audio_data)
    temp_audio_path = 'temp_audio.mp3'
    with open(temp_audio_path, 'wb') as temp_audio_file:
        temp_audio_file.write(audio_bytes)
    audio_clip = AudioFileClip(temp_audio_path)
    os.remove(temp_audio_path)
    return audio_clip

def update_image_selected(image_id, image_selected):
    try:
        cursor.execute("UPDATE Images SET image_selected = %s WHERE image_id = %s", (image_selected, image_id))
    finally:
        connection.commit()

@app.route('/update_image_selected', methods=['POST'])
def update_image_selected_route():
    data = request.get_json()
    image_id = data.get('image_id')
    image_selected = data.get('image_selected')
    update_image_selected(image_id, image_selected)
    return jsonify({'success': True})

@app.route('/update_image', methods=['POST'])
def update_image():
    image_id = request.form.get('image_id')
    image_duration = request.form['image_duration']
    image_transition = request.form['image_transition']

    try:
        cursor.execute("""
            UPDATE Images 
            SET image_duration = %s, image_transition = %s
            WHERE image_id = %s
        """, (image_duration, image_transition, image_id))
        connection.commit()
        return jsonify({'success': True})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

def update_audio_id(audioId, frames):
    sql_query = """
        UPDATE Images
        SET audio_id = %s
        WHERE image_selected = 1
        AND audio_id = 0
        ORDER BY image_id
        LIMIT %s;
    """
    cursor.execute(sql_query, (audioId, frames))
    connection.commit()            

@app.route('/add_audio',methods=['POST'])
def update_audio_id_route():
    audioId=request.form['audio_id']
    frames=int(request.form['frames'])
    update_audio_id(audioId,frames)
    return jsonify({'success': True})

def retrieve_image_data(user_id, video_quality="720p"):
    cursor.execute("SELECT image_blob, image_duration FROM Images WHERE user_id = %s AND image_selected=1", (user_id,))
    image_records = cursor.fetchall()
    cursor.execute("SELECT audio_id FROM Images WHERE user_id = %s AND image_selected=1", (user_id,))
    audio_records = cursor.fetchall()
    cursor.execute("SELECT image_transition FROM Images WHERE user_id = %s AND image_selected=1", (user_id,))
    transitions = cursor.fetchall()
    return image_records, audio_records, video_quality, transitions

def create_video(image_records, audio_records, video_quality, transitions): 
    output_video_path = 'static/final_output_video.mp4'
    if os.path.exists(output_video_path):
        os.remove(output_video_path)
    if video_quality == '720p':
        frame_width = 1280
        frame_height = 720
    elif video_quality == '1080p':
        frame_width = 1920
        frame_height = 1080
    elif video_quality == '480p':
        frame_width = 854
        frame_height = 480
    else:
        frame_width = 1280
        frame_height = 720
    fps = 24

    video_frames = []

    segment_durations = []

    audio_clips = []

    current_audio_id = None
    current_duration = 0

    for image_data, image_duration in image_records:
        img = np.array(Image.open(io.BytesIO(image_data)))
        if img is not None:
            if img.shape[2] == 4:  
                img = cv2.cvtColor(img, cv2.COLOR_RGBA2RGB) 
            img = cv2.resize(img, (frame_width, frame_height))
            for _ in range(int(fps * image_duration)):
                video_frames.append(img)
            segment_durations.append(image_duration)
            audio_id = audio_records.pop(0) 
            if audio_id != 0:  
                if audio_id[0] == current_audio_id: 
                    current_duration += image_duration 
                else:
                    if current_audio_id is not None:  
                        audio_clips.append((current_audio_id, current_duration))
                    current_audio_id = audio_id[0]
                    current_duration = image_duration
            else:
                audio_clips.append((0, image_duration))

    video_clip = ImageSequenceClip(video_frames, fps=fps)

    if current_audio_id is not None:
        audio_clips.append((current_audio_id, current_duration))

    background_audio_clips = []
    for audio_id, duration in audio_clips:
        if audio_id == -1: 
            audio_path = f'./static/audio1.mp3'
            background_audio_clip = AudioFileClip(audio_path)   
            background_audio_clip = background_audio_clip.subclip(0, duration)  
            background_audio_clips.append(background_audio_clip)
        elif audio_id == -2: 
            audio_path = f'./static/audio2.mp3'
            background_audio_clip = AudioFileClip(audio_path)
            background_audio_clip = background_audio_clip.subclip(0, duration)  
            background_audio_clips.append(background_audio_clip)
        elif audio_id == -3:  
            audio_path = f'./static/audio3.mp3'
            background_audio_clip = AudioFileClip(audio_path)
            background_audio_clip = background_audio_clip.subclip(0, duration) 
            background_audio_clips.append(background_audio_clip)
        elif audio_id == -4: 
            audio_path = f'./static/audio4.mp3'
            background_audio_clip = AudioFileClip(audio_path)
            background_audio_clip = background_audio_clip.subclip(0, duration)
            background_audio_clips.append(background_audio_clip)
            
        elif audio_id==0:
            audio_path = './static/silent_audio.mp3'
            background_audio_clip = AudioFileClip(audio_path)
            background_audio_clip = background_audio_clip.subclip(0, duration) 
            background_audio_clips.append(background_audio_clip)

        else:
            background_audio_clip = fetch_audio_from_database(audio_id)
            background_audio_clip = background_audio_clip.subclip(0, duration)  
            background_audio_clips.append(background_audio_clip)

    final_audio_clip = concatenate_audioclips(background_audio_clips)
    video_duration = sum(segment_durations)
    final_audio_clip = final_audio_clip.subclip(0, video_duration)

    video_clip = video_clip.set_audio(final_audio_clip)
    processed_clips = []
    
    start_time = 0
    for i,transition_code in enumerate(transitions):
        transition = transition_code[0]
        duration = segment_durations[i]
        if transition==1:
            segment = video_clip.subclip(start_time, start_time + duration)
            segment_with_fadein = segment.fx(fadein, duration=1)
            segment_with_fadein_and_out = segment_with_fadein.fx(fadeout, duration=1)
            processed_clips.append(segment_with_fadein_and_out)
            start_time += duration
                
        elif transition==2:
            segment = video_clip.subclip(start_time, start_time + duration)
            segment_with_fadein = segment.fx(fadein, duration=1)
            processed_clips.append(segment_with_fadein)
            start_time += duration
        elif transition==3:
            segment = video_clip.subclip(start_time, start_time + duration)
            segment_with_fadeout = segment.fx(fadeout, duration=1)
            processed_clips.append(segment_with_fadeout)
            start_time += duration
        elif transition==0:
            segment = video_clip.subclip(start_time, start_time + duration)
            processed_clips.append(segment)
            start_time += duration
    
    video_clip = mp.concatenate_videoclips(processed_clips, method="compose")
    video_clip.write_videofile(output_video_path, codec="libx264", fps=fps)

    video_clip.close()
    final_audio_clip.close()

@app.route('/loading')
def loading():
    return render_template('loading.html')

@app.route('/video')
def generate_video():
    image_records, audio_records, video_quality, transitions = retrieve_image_data(session.get('user_id'))
    create_video(image_records, audio_records, video_quality, transitions)
    return render_template('video.html')

@app.route('/logout')
def logout():
    output_video_path = 'static/final_output_video.mp4'
    if os.path.exists(output_video_path):
        os.remove(output_video_path)
    session.clear()  
    return redirect('/login')

if __name__ == '__main__':
    app.run(debug=True)
